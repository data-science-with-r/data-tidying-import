{
  "hash": "10d658fc62c29c6f200d58ff3262b151",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Nobel Prize winners & sales data\"\ntoc: true\nwebr:\n  packages: ['tidyverse', 'scales', 'readxl']\nfilters:\n  - webr\n---\n\n\n## Packages\n\nWe will use the following two packages in this application exercise.\n\n-   **tidyverse**: For data import, wrangling, and visualization.\n-   **readxl:** For importing data from Excel.\n\n\n::: {.cell}\n\n:::\n\n\n## Nobel Prize winners\n\nFor this exercise, we are going to work with a Nobel Prize winners dataset from the years 1901 through 2018. Please read in the following data below.\n\n```{webr-r}\n#| context: setup\ndownload.file(\n  \"https://raw.githubusercontent.com/ElijahMeyer3/Coursera/main/data/nobel.csv\",\n  \"nobel.csv\"\n)\n\ndownload.file(\n  \"https://raw.githubusercontent.com/ElijahMeyer3/Coursera/main/data/sales.xlsx\",\n  \"sales.xlsx\"\n)\n\noptions(readr.show_progress = FALSE)\n```\n\n\n::: {.cell}\n\n:::\n\n\n```{webr-r}\nnobel <- read_csv(\"nobel.csv\")\n```\n\nBased on the tibble output, what are the number of rows and columns of the `nobel` dataset? What types of variables are you working with?\n\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\nThere are 935 rows and 26 columns in nobel dataset.\n\nThere are 21 character variables, 3 dbl variables, and 2 date variables\n:::\n\nNow, rerun the code above to read in the dataset, but use the argument `show_col_types = FALSE` to suppress the given dataset information. Note that, if done correctly, you won't see any output.\n\n```{webr-r}\nnobel <- read_csv(\"nobel.csv\", # add code here)\n```\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnobel <- read_csv(\"nobel.csv\", show_col_types = FALSE)\n```\n:::\n\n\nNotice that there is no given message when running the code. This code simply loads the dataset.\n:::\n\n## Type coercion\n\nWe are going to use the `nobel` dataset to explore type coercion. Using `glimpse()`, identify what type of variable `gender` is in this dataset. Additionally, identify the levels of this variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# add response here\n```\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(nobel)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 935\nColumns: 26\n$ id                    <dbl> 1, 2, 3, 4, 5, 6, 6, 8, 9, 10, 11, 12, 13, 14, 1…\n$ firstname             <chr> \"Wilhelm Conrad\", \"Hendrik A.\", \"Pieter\", \"Henri…\n$ surname               <chr> \"Röntgen\", \"Lorentz\", \"Zeeman\", \"Becquerel\", \"Cu…\n$ year                  <dbl> 1901, 1902, 1902, 1903, 1903, 1903, 1911, 1904, …\n$ category              <chr> \"Physics\", \"Physics\", \"Physics\", \"Physics\", \"Phy…\n$ affiliation           <chr> \"Munich University\", \"Leiden University\", \"Amste…\n$ city                  <chr> \"Munich\", \"Leiden\", \"Amsterdam\", \"Paris\", \"Paris…\n$ country               <chr> \"Germany\", \"Netherlands\", \"Netherlands\", \"France…\n$ born_date             <date> 1845-03-27, 1853-07-18, 1865-05-25, 1852-12-15,…\n$ died_date             <date> 1923-02-10, 1928-02-04, 1943-10-09, 1908-08-25,…\n$ gender                <chr> \"male\", \"male\", \"male\", \"male\", \"male\", \"female\"…\n$ born_city             <chr> \"Remscheid\", \"Arnhem\", \"Zonnemaire\", \"Paris\", \"P…\n$ born_country          <chr> \"Germany\", \"Netherlands\", \"Netherlands\", \"France…\n$ born_country_code     <chr> \"DE\", \"NL\", \"NL\", \"FR\", \"FR\", \"PL\", \"PL\", \"GB\", …\n$ died_city             <chr> \"Munich\", NA, \"Amsterdam\", NA, \"Paris\", \"Sallanc…\n$ died_country          <chr> \"Germany\", \"Netherlands\", \"Netherlands\", \"France…\n$ died_country_code     <chr> \"DE\", \"NL\", \"NL\", \"FR\", \"FR\", \"FR\", \"FR\", \"GB\", …\n$ overall_motivation    <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ share                 <dbl> 1, 2, 2, 2, 4, 4, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, …\n$ motivation            <chr> \"\\\"in recognition of the extraordinary services …\n$ born_country_original <chr> \"Prussia (now Germany)\", \"the Netherlands\", \"the…\n$ born_city_original    <chr> \"Lennep (now Remscheid)\", \"Arnhem\", \"Zonnemaire\"…\n$ died_country_original <chr> \"Germany\", \"the Netherlands\", \"the Netherlands\",…\n$ died_city_original    <chr> \"Munich\", NA, \"Amsterdam\", NA, \"Paris\", \"Sallanc…\n$ city_original         <chr> \"Munich\", \"Leiden\", \"Amsterdam\", \"Paris\", \"Paris…\n$ country_original      <chr> \"Germany\", \"the Netherlands\", \"the Netherlands\",…\n```\n\n\n:::\n\n```{.r .cell-code}\nnobel |>\n  group_by(gender) |>\n  count(gender)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n# Groups:   gender [3]\n  gender     n\n  <chr>  <int>\n1 female    52\n2 male     856\n3 org       27\n```\n\n\n:::\n:::\n\n\n`gender` is a character variable. This variable has three different genders: `male`, `female`, and `org`.\n:::\n\nSuppose we want to turn the three listed genders into numeric values. Run the following code. What happened?\n\n```{webr-r}\nnobel |>\n  mutate(gender = as.numeric(gender)) |>\n  select(gender)\n```\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\nWhen trying to change `male`, `female` and `org` into numbers from characters, each value became an NA.\n:::\n\nIf we want the function `as.numeric()` to coerce these values into numbers, we need to change them to be a factor first. Run the following code, and compare the results. What values were assigned to which group? How do you think R determined this?\n\n```{webr-r}\nnobel |>\n  mutate(gender_num = as.numeric(as.factor(gender))) |>\n  select(gender, gender_num) |>\n  unique()\n```\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\nR assigned male = 2; female = 1; and org = 3. These were assigned alpha-numerically.\n:::\n\nNote, that you can also avoid type coercion by manually setting values (see example code below).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnobel |>\n  mutate(gender_num = case_when(\n    gender == \"female\" ~ 1,\n    gender == \"male\" ~ 2,\n    gender == \"org\" ~ 3\n  )) |>\n  select(gender, gender_num) |>\n  unique()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  gender gender_num\n  <chr>       <dbl>\n1 male            2\n2 female          1\n3 org             3\n```\n\n\n:::\n:::\n\n\nSuppose you wanted to make this change to the `nobel` dataset, and export a new csv to your current working directory on your local installment. This can be accomplished using `write_csv()`. See the help file [here](https://www.rdocumentation.org/packages/readr/versions/0.1.0/topics/write_csv).\n\n## Sales\n\nFor the remaining part of this exercise, we are going to learn how to read in and clean up data that come from Excel. The messy data that we are going to work with can be seen in below.\n\n![](images/salex-excel.png){fig-align=\"center\" width=\"801\"}\n\nWe are going to use `read_excel()` to read in a xlsx Excel file. Read in the file and take a glimpse of these data. Why can we not work with these data in their current form?\n\n```{webr-r}\n#| label: sales-import\nsales <- read_excel(\n  \"sales.xlsx\"\n)\n\nglimpse(sales)\n```\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\nThese data are not tidy. These data are read in with the text as a column name, and creates another column name called `...2`.\n:::\n\nSee the help file for `read_excel()` [here](https://www.rdocumentation.org/packages/readxl/versions/0.1.1/topics/read_excel). Notice that, in the current `sales` dataset, we want to skip 3 rows (the first row acts as a header for the column names). We can do this using the `skip` argument. At the same time, we can specify names for each column by giving the argument `col_names` a character vector. Use these arguments and add to the code below to skip 3 lines and name the columns `id` and `n`.\n\n```{webr-r}\nsales <- read_excel(\n  \"sales.xlsx\", \n# add code here\n)\n```\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsales <- read_excel(\n  \"sales.xlsx\",\n  skip = 3,\n  col_names = c(\"id\", \"n\")\n)\n\nsales\n```\n:::\n\n:::\n\n## Putting it all together\n\nManipulate the sales data such such that it looks like the following using functions you have learned from the `tidyverse` to transform data.\n\n![](images/sales-2.png){width=\"300\"}\n\n```{webr-r}\nread_excel(\n  \"sales.xlsx\", \n  skip = 3,\n  col_names = c(\"id\", \"n\")\n) |>\n# add code here\n```\n\n::: {.callout-tip collapse=\"true\"}\n## Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsales |>\n  mutate(\n    is_brand_name = str_detect(id, \"Brand\"),\n    brand = if_else(is_brand_name, id, NA)\n  ) |>\n  fill(brand) |>\n  filter(!is_brand_name) |>\n  select(brand, id, n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 3\n  brand   id    n    \n  <chr>   <chr> <chr>\n1 Brand 1 1234  8    \n2 Brand 1 8721  2    \n3 Brand 1 1822  3    \n4 Brand 2 3333  1    \n5 Brand 2 2156  3    \n6 Brand 2 3987  6    \n7 Brand 2 3216  5    \n```\n\n\n:::\n:::\n\n:::\n\n**Takeaway** We should write code to manipulate data instead of opening Excel and editing the data in there because it allows us to re-use the data multiple times, and leaves a transparent trail of any modifications done while manipulating the data. Changing data in Excel is neither reproducible nor reusable.\n",
    "supporting": [
      "noble_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}