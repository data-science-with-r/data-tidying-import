{
  "hash": "1db413b340e4266d321fdcf198ffc705",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data classes\"\nformat: revealjs\n---\n\n\n\n\n\n# Data classes\n\n## Data classes\n\nWe talked about *types* so far, next we'll introduce the concept of *classes*\n\n::: incremental\n- Vectors are like Lego building blocks\n- We stick them together to build more complicated constructs, e.g. *representations of data*\n- The **class** attribute relates to the S3 class of an object which determines its behaviour\n  - You don't need to worry about what S3 classes really mean, but you can read more about it [here](https://adv-r.hadley.nz/s3.html#s3-classes) if you're curious\n- Examples: factors, dates, and data frames\n:::\n\n## Factors\n\nR uses factors to handle categorical variables, variables that have a fixed and known set of possible values\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- factor(c(\"BS\", \"MS\", \"PhD\", \"MS\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] BS  MS  PhD MS \nLevels: BS MS PhD\n```\n\n\n:::\n:::\n\n\n\n:::: {.columns}\n\n::: {.column width=\"35%\" .fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"35%\" .fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\n:::\n\n::::\n\n## More on factors\n\nWe can think of factors like character (level labels) and an integer (level numbers) glued together\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Factor w/ 3 levels \"BS\",\"MS\",\"PhD\": 1 2 3 2\n```\n\n\n:::\n\n```{.r .cell-code}\nas.integer(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 2\n```\n\n\n:::\n:::\n\n\n\n## Dates\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- as.Date(\"2025-01-01\")\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-01-01\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Date\"\n```\n\n\n:::\n:::\n\n\n\n## More on dates\n\nWe can think of dates like an integer (the number of days since the origin, 1 Jan 1970) and an integer (the origin) glued together\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.integer(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20089\n```\n\n\n:::\n\n```{.r .cell-code}\nas.integer(y) / 365 # roughly 55 yrs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55.03836\n```\n\n\n:::\n:::\n\n\n\n## Data frames\n\nWe can think of data frames like like vectors of equal length glued together\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:2, y = 3:4)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y\n1 1 3\n2 2 4\n```\n\n\n:::\n:::\n\n\n\n:::: {.columns}\n\n::: {.column width=\"35%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"35%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n:::\n\n::::\n\n## Lists\n\nLists are a generic vector container; vectors of any type can go in them\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2|3|4\"}\nl <- list(\n  x = 1:4,\n  y = c(\"hi\", \"hello\", \"jello\"),\n  z = c(TRUE, FALSE)\n)\nl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$x\n[1] 1 2 3 4\n\n$y\n[1] \"hi\"    \"hello\" \"jello\"\n\n$z\n[1]  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n## Lists and data frames\n\n- A data frame is a special list containing vectors of equal length\n- When we use the `pull()` function, we extract a vector from the data frame\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y\n1 1 3\n2 2 4\n```\n\n\n:::\n\n```{.r .cell-code}\ndf |>\n  pull(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4\n```\n\n\n:::\n:::\n\n\n\n# Working with factors\n\n## Read data in as character strings\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhandedness <- read_csv(\"data/handedness.csv\")\nglimpse(handedness)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 60\nColumns: 2\n$ name       <chr> \"Abdiel Camacho\", \"Abram Sanders\", \"Ady…\n$ preference <chr> \"left\", \"ambidextrous\", \"right\", \"right…\n```\n\n\n:::\n:::\n\n\n\n## But coerce when plotting\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(handedness, mapping = aes(x = preference)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](2-2-data-classes_files/figure-revealjs/unnamed-chunk-14-1.png){width=90%}\n:::\n:::\n\n\n\n## Use forcats to manipulate factors\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2\"}\nhandedness |>\n  mutate(preference = fct_infreq(preference)) |>\n  ggplot(mapping = aes(x = preference)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](2-2-data-classes_files/figure-revealjs/unnamed-chunk-15-1.png){width=90%}\n:::\n:::\n\n\n\n## Come for the functionality\n\n:::: {.columns}\n\n::: {.column width=\"35%\"}\n... stay for the logo\n:::\n\n::: {.column width=\"35%\"}\n![](images/forcats-part-of-tidyverse.png)\n:::\n\n::::\n\n- The **forcats** package provides a suite of useful tools that solve common problems with factors\n- Factors are useful when you have true categorical data and you want to override the ordering of character vectors to improve display\n- They are also useful in modeling scenarios\n",
    "supporting": [
      "2-2-data-classes_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}